<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>arch on avances123</title>
    <link>http://blog.fabio.xyz/tags/arch/</link>
    <description>Recent content in arch on avances123</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-es</language>
    <lastBuildDate>Thu, 14 Apr 2016 10:30:57 +0100</lastBuildDate>
    <atom:link href="http://blog.fabio.xyz/tags/arch/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Montando un firewall nftables</title>
      <link>http://blog.fabio.xyz/post/nftables-archlinux/</link>
      <pubDate>Thu, 14 Apr 2016 10:30:57 +0100</pubDate>
      
      <guid>http://blog.fabio.xyz/post/nftables-archlinux/</guid>
      <description>

&lt;h1 id=&#34;montar-un-firewall-con-nftables-para-nuestro-servidor&#34;&gt;Montar un firewall con nftables para nuestro servidor&lt;/h1&gt;

&lt;p&gt;Todos conocemos iptables, al menos de oidas, de poner alguna regla normalmente copiada de algun blog como este para enrutar trafico o abrir algun puerto. En este caso vamos a hacer lo mismo, pero con nftables, que es digamos la evolucion de iptables , y tiene soporte para ipv6 y arp mejorada a la que tiene iptables, ademas de una sintaxis mas amigable.&lt;/p&gt;

&lt;p&gt;Es necesario tener un kernel &amp;gt;=3.13&lt;/p&gt;

&lt;h2 id=&#34;instalacion&#34;&gt;Instalacion&lt;/h2&gt;

&lt;p&gt;Asi de sencillo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pacman -S nftables
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;desactivacion-de-iptables&#34;&gt;Desactivacion de iptables&lt;/h2&gt;

&lt;p&gt;Yo estaba usando iptables con un conjunto de reglas, vamos a deshabilitarlo en el systemd y a comprobar que no tenemos ninguna regla activa:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ systemctl stop iptables
$ systemctl disable iptables
$ iptables -nvL
Chain INPUT (policy ACCEPT 72M packets, 83G bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain FORWARD (policy ACCEPT 1639K packets, 230M bytes)
 pkts bytes target     prot opt in     out     source               destination

Chain OUTPUT (policy ACCEPT 52M packets, 10G bytes)
 pkts bytes target     prot opt in     out     source               destination
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ahora tenemos nuestro servidor abierto a todo, sin ningun tipo de reglas, y asi seguira porque hemos hecho disable.&lt;/p&gt;

&lt;h2 id=&#34;configuracion-de-nftables&#34;&gt;Configuracion de nftables&lt;/h2&gt;

&lt;p&gt;Por supuesto no voy a competir con la estupenda documentacion de arch linux sobre &lt;a href=&#34;https://wiki.archlinux.org/index.php/nftables&#34;&gt;nftables&lt;/a&gt;. Voy a empezar con el fichero de ejemplo que esta en &lt;code&gt;/etc/nftables.conf&lt;/code&gt;. En este fichero viene la tipica configuracion de te capo todo menos el ssh para que sigas configurando y no se te quede cara de pipas.&lt;/p&gt;

&lt;p&gt;Segun abrimos el fichero no entendemos mucho, pero el caso es pensar igual que con iptables, es exactamente igual pero digamos que puedes escribir cosas en mas sitios para mejorar la organizacion, pero los conceptos son los mismos.&lt;/p&gt;

&lt;p&gt;Estan las &lt;em&gt;rules&lt;/em&gt; que son la tipica linea de iptables, donde segun el paquete que venga, si hace match , hacemos cosas (solemos aceptarlo o rechazarlo).
Estan las &lt;em&gt;chains&lt;/em&gt; que son agrupaciones de rules, solo que en lugar de tenerlas mas o menos fijas, aqui podemos tener tantas como queramos llamarlas como queramos y en general, son mas flexibles, en el fichero por ejemplo tenemos tres chains que se llaman como las antiguas de iptables, pero se podrian llamar de otra manera, el caso es, cuando entrara un paquete por ella? bueno porque en la primera de una chain de nftables debes definir sus propiedades, es decir escribir una linea de este tipo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;type filter hook input priority 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esto significa que esta chain filtrara, (simplificando se dedicara a aceptar o rechazar paquetes), y se lanzara cuando tenga el hook input, es decir cuando en el destino del paquete aparezca la ip de nuestro servidor, es decir, entra en nosotros. Tambien hay hooks &lt;code&gt;output,forward,prerouting y postrouting&lt;/code&gt; como en iptables.&lt;/p&gt;

&lt;h2 id=&#34;activar-al-inicio&#34;&gt;Activar al inicio&lt;/h2&gt;

&lt;p&gt;Una vez tengamos nuestras reglas puestas en &lt;code&gt;/etc/nftables.conf&lt;/code&gt; podemos cargarlas en cada arranque.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ systemctl enable nftables
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Instalacion de grafana, influxdb y collectd</title>
      <link>http://blog.fabio.xyz/series/arch-homeserver/collectd-influxdb-grafana-en-archlinux/</link>
      <pubDate>Thu, 07 Apr 2016 10:30:57 +0100</pubDate>
      
      <guid>http://blog.fabio.xyz/series/arch-homeserver/collectd-influxdb-grafana-en-archlinux/</guid>
      <description>

&lt;h1 id=&#34;sacando-graficas-de-todo-en-tu-red-casera&#34;&gt;Sacando graficas de todo en tu red casera&lt;/h1&gt;

&lt;p&gt;Hoy vamos a montar el sistema de metricas para nuestro servidor casero, la arquitectura sera la siguiente:
1. Una base de datos especial para series temporales llamada &lt;a href=&#34;https://www.influxdata.com/time-series-platform/influxdb/&#34;&gt;influxdb&lt;/a&gt;
2. Un frontend para pintar las graficas llamado &lt;a href=&#34;http://grafana.org/&#34;&gt;grafana&lt;/a&gt;
3. Un ligero demonio en cada sistema de nuestra red (incluido nuestro servidor) para sacar los datos y mandarlos a la db, llamado &lt;a href=&#34;https://collectd.org/&#34;&gt;collectd&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vamos a ver la instalacion y configuracion de cada uno de los programas.&lt;/p&gt;

&lt;h2 id=&#34;influxdb&#34;&gt;influxdb&lt;/h2&gt;

&lt;p&gt;Influxdb es otra base de datos mas, enfocada en almacenar datos en timeseries, esta escrita en Go y es de codigo abierto. La uso para almacenar las tipicas metricas del servidor y pintarlas en graficas tipo munin, pero espero algun dia experimentar mas con ella ahora que esta en la version v1.0. Quiza algun benchmark de alguna variable de meteo en postgresql vs influxdb o algo asi.&lt;/p&gt;

&lt;p&gt;Esto quiere decir que no vale solo para pintar la ram de nuestro ordenador, esta db tiene de serie una API HTTP donde con una sola request podemos enviarle datos. Asi que enviar un numero desde cualquier programa bastaria con ponerle un GET a ese programa enviando el dato.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;yaourt -S influxdb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Editamos &lt;code&gt;/etc/influxdb/influxdb.conf&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;grafana&#34;&gt;grafana&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pacman -S grafana
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;collectd&#34;&gt;collectd&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo pacman -S collectd
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Introduccion, que tenia antes y que he comprado</title>
      <link>http://blog.fabio.xyz/series/arch-homeserver/de-raspberry-pi-a-hp-proliant-microserver/</link>
      <pubDate>Thu, 07 Apr 2016 10:30:57 +0100</pubDate>
      
      <guid>http://blog.fabio.xyz/series/arch-homeserver/de-raspberry-pi-a-hp-proliant-microserver/</guid>
      <description>

&lt;h2 id=&#34;antecedentes&#34;&gt;Antecedentes&lt;/h2&gt;

&lt;p&gt;Bueno pues yo tenia en mi casa una raspberry pi, para hacer de media center y algun servicio de red mas, la tipica raspberry con un disco duro enchufado por usb.&lt;/p&gt;

&lt;p&gt;Todo iba genial como muchos que la teneis en casa sabreis, mis pegas eran totalmente menores, que era ARM y que era ubuntu, llevo 1 a単o ahora que me he cambiado a Archlinux como sistema operativo principal y aunque he usado ubuntu durante a単os, queria cambiarme a arch linux, por supuesto muchisimo de lo que contare aqui funciona en &lt;a href=&#34;https://archlinuxarm.org/&#34;&gt;Archlinux ARM&lt;/a&gt;, para vuestras raspberrys, odroids y demas.&lt;/p&gt;

&lt;h2 id=&#34;un-servidor-hp-en-casa&#34;&gt;Un servidor hp en casa&lt;/h2&gt;

&lt;p&gt;Por la indicacion de un compa単ero del que siempre confio en cuanto a compras de tecnologia, me comento que habia un servidor casero muy barato, realmente son 200 euros, (4 veces mas que la pi), pero realmente era la posibilidad de tener un servidor &lt;em&gt;empresarial&lt;/em&gt; en casa. Es el &lt;a href=&#34;http://www8.hp.com/es/es/products/proliant-servers/product-detail.html?oid=5379860#!tab=specs&#34;&gt;HP Proliant Microserver gen8&lt;/a&gt;, supongo que han sacado otra version mas nueva y esta aun la venden en amazon, pero por ese precio me parecio muy barato. Gasta mas que la pi, pero no tengo que tener el disco duro enchufao ahi con cables por usb 2.0 y asi podria seguir justificandome un rato mas, en general digamos que es un salto mas, en potencia y en gasto como es normal.&lt;/p&gt;

&lt;p&gt;El servidor esta muy bien, tiene una bios muy pro, no hace nada de ruido y diria que hasta es bonito, tiene dos tarjetas de red, y otra dedicada para su gestion remota.&lt;/p&gt;

&lt;h2 id=&#34;montando-los-discos&#34;&gt;Montando los discos&lt;/h2&gt;

&lt;p&gt;Bueno como muchos de vosotros, yo tengo en mi casa varios discos cada uno de su padre y de su madre, uno que he robado de un pc viejo, otro que me he comprado, otro que me lo dio mi hermano, etc. Esta maquina tiene cuatro bahias para discos duros&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://blog.fabio.xyz/images/proliant_1.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Justo tenia 4 asi que los 4 para dentro, son de tama単o distintos y aunque este servidor tiene controladora RAID, yo los pinche y luego en el Arch ya los gestionaria. No se pueden pinchar en caliente, asi que hay que hacerlo con el servidor apagado, y una cosa que tiene tener un servidor mas empresarial, es que tardan en arrancar la vida, asi que pensaroslo bien!.&lt;/p&gt;

&lt;h2 id=&#34;montando-el-so&#34;&gt;Montando el SO&lt;/h2&gt;

&lt;p&gt;Para el sistema operativo, correria en un usb para no tener el sistema en ninguno de mis cuatro discos, y dedicarlos a hacer mantener los datos, sin tener el sistema entre ellos &lt;em&gt;molestando&lt;/em&gt;. Para montar un arch linux en un usb, seria del genero tonto documentar cosas que estan en la estupendisima &lt;a href=&#34;https://wiki.archlinux.org/index.php/Installing_Arch_Linux_on_a_USB_key&#34;&gt;wiki&lt;/a&gt;. Pero bueno en general lo interesante de este paso es saber que el sistema esta en un usb, el usb tiene una escritura reducida asi que hay que minimizarla al maximo, en mi caso sacaria la particion &lt;code&gt;/var&lt;/code&gt; y la &lt;code&gt;/home&lt;/code&gt; a los discos de las bahias, y asi tendria el pincho usb sin casi escritura.&lt;/p&gt;

&lt;p&gt;Sobre la configuracion del sistema operativo pues hablare constantemente en esta serie, pero sobre la &lt;a href=&#34;https://wiki.archlinux.org/index.php/Installation_guide&#34;&gt;instalacion desde cero&lt;/a&gt; de arch, no voy a poner nada ya que creo que no aporta nada de valor.&lt;/p&gt;

&lt;h3 id=&#34;kernel&#34;&gt;kernel&lt;/h3&gt;

&lt;p&gt;Una cosa importante en este paso, instalar el kernel lts, que tiene menos actualizaciones, y bloquearlo, no queremos que nuestro servidor este cambiando de kernel tan tranquilamente, funciona y no hace falta actualizarlo, recordad que buscamos la estabilidad aqui.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo pacman -S linux-lts
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# /etc/pacman.conf

...
IgnorePkg = linux-lts linux-lts-headers
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Con esto conseguimos tener dos kernels en nuestro grub, el paquete linux, con el kernel actualizandose a menudo , y el paquete linux-lts, que es un kernel mas estable y ademas bloqueado, lo actualiaremos cuando &lt;strong&gt;necesitemos&lt;/strong&gt;.Este sera nuestro kernel por defecto en el arranque.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Montando el almacenamiento con btrfs</title>
      <link>http://blog.fabio.xyz/series/arch-homeserver/almacenamiento-con-btrfs/</link>
      <pubDate>Thu, 07 Apr 2016 10:30:57 +0100</pubDate>
      
      <guid>http://blog.fabio.xyz/series/arch-homeserver/almacenamiento-con-btrfs/</guid>
      <description>

&lt;h2 id=&#34;configurar-el-almacenamiento-con-btrfs&#34;&gt;Configurar el almacenamiento con btrfs&lt;/h2&gt;

&lt;p&gt;El siguiente paso sera configurar el almacenamiento, ya tenemos enchufados los discos y los reconoce el Linux&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo fdisk -l | grep Disco
Disco /dev/sdc: 465,8 GiB, 500107862016 bytes, 976773168 sectores
Disco /dev/sdb: 698,7 GiB, 750156374016 bytes, 1465149168 sectores
Disco /dev/sda: 2,7 TiB, 3000592982016 bytes, 5860533168 sectores
Disco /dev/sde: 465,8 GiB, 500107862016 bytes, 976773168 sectores
Disco /dev/sdd: 14,7 GiB, 15733161984 bytes, 30728832 sectores
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Los discos &lt;code&gt;/dev/sd[a,b,c,e]&lt;/code&gt; son los discos de 3&amp;rsquo;5 que he pinchado en las bahias y &lt;code&gt;/dev/sdd&lt;/code&gt; es el pincho usb donde tenemos nuestro sistema. Ahora vamos a configurar btrfs para tener un solo sistema de ficheros y ya a partir de ese btrfs, crearemos volumenes y montaremos a nuestro gusto. He intentado estudiar y hacerlo lo mejor posible segun he leido en la wiki de arch y mi propia experiencia.&lt;/p&gt;

&lt;p&gt;Os podreis preguntar por que el pincho usb no es la primera o la ultima letra sdX, el caso es que no los pinche a la vez, reinicie quiza, en todo caso, siempre haremos caso a los UUID de los discos, y dejaremos las antiguas letras sdX como quiera udev ponernoslas.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ blkid
/dev/sdc: LABEL=&amp;quot;raid&amp;quot; UUID=&amp;quot;3e1cedae-3ca0-48f1-8170-e322de78f91e&amp;quot; UUID_SUB=&amp;quot;171c1b29-e14c-4d81-afd5-f30957d1395d&amp;quot; TYPE=&amp;quot;btrfs&amp;quot;
/dev/sdb: LABEL=&amp;quot;raid&amp;quot; UUID=&amp;quot;3e1cedae-3ca0-48f1-8170-e322de78f91e&amp;quot; UUID_SUB=&amp;quot;63b3e7a1-4a9c-4846-9c94-ff533acfc698&amp;quot; TYPE=&amp;quot;btrfs&amp;quot;
/dev/sda: LABEL=&amp;quot;raid&amp;quot; UUID=&amp;quot;3e1cedae-3ca0-48f1-8170-e322de78f91e&amp;quot; UUID_SUB=&amp;quot;8ebb3acf-0b03-48f7-9188-f716d98cb0aa&amp;quot; TYPE=&amp;quot;btrfs&amp;quot;
/dev/sde: UUID=&amp;quot;1c119d46-0a5d-41c1-a2e8-82e76d6e6654&amp;quot; UUID_SUB=&amp;quot;60701c41-b238-4155-b180-ae805c106fdb&amp;quot; TYPE=&amp;quot;btrfs&amp;quot;
/dev/sdd1: UUID=&amp;quot;12a25f83-65fa-457c-878e-758dfe79f2b1&amp;quot; TYPE=&amp;quot;ext4&amp;quot; PARTUUID=&amp;quot;3dd32031-01&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Asi vemos los UUID, como podeis ver, he utilizado 3 discos para un sistema btrfs, que tiene el mismo UUID y distintos UUID_SUB, lo he puesto el label &lt;em&gt;RAID&lt;/em&gt; aunque no lo sea.&lt;/p&gt;

&lt;p&gt;Ademas &lt;code&gt;/dev/sde&lt;/code&gt; lo he utilizado para crear un sistema de ficheros distinto, este disco ira a parte de los otros. Mas adelante explicare por que he hecho esto, ya que no tiene una razon aplastante, quiero montar mi base de datos en ese disco y preferia tenerla en un disco fisico aislado.&lt;/p&gt;

&lt;p&gt;Nos falta &lt;code&gt;/dev/sdd1&lt;/code&gt; que es la particion del pincho usb donde esta el sistema, este lo he formateado con ext4, nada nuevo. Segun los propios desarrolladores de btrfs, dicen que este sistema funciona muy bien en hardware como este, asi que lanzaros y poned btrfs en el pincho tambien!, yo no lo tengo porque al formatearlo y meter el arch aun no tenia claro nada, y para no fallar, pues como siempre no?&lt;/p&gt;

&lt;h3 id=&#34;creacion-del-sistema-de-ficheros&#34;&gt;Creacion del sistema de ficheros&lt;/h3&gt;

&lt;p&gt;Pues una vez tengamos los discos reconocidos por el sistema, solo hay que formatearlos con mkfs como siempre&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkfs.btrfs /dev/sda /dev/sdb /dev/sdc
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;montaje&#34;&gt;Montaje&lt;/h3&gt;

&lt;p&gt;He creado un directorio en el raiz llamado &lt;code&gt;/data&lt;/code&gt; y montare ahi mi sistema de ficheros.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mount /dev/sda /data
$ mount
/dev/sdb on /data type btrfs (rw,relatime,compress=lzo,space_cache,autodefrag,subvolid=5,subvol=/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como se puede ver, las opciones de montaje no son las de por defecto, aunque estas son correctas para un primer montaje, lo ideal es tunearlo segun nuestro uso, para el caso de mis datos, le he puesto la opcion &lt;code&gt;compress=lzo&lt;/code&gt; que reduce (muy poco) el espacio de almacenamiento y aumenta el rendimiento. Tambien la opcion de &lt;code&gt;autodefrag&lt;/code&gt;. Todas estas opciones estan persistidas en el fichero &lt;code&gt;/etc/fstab&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ grep &#39;/data&#39; /etc/fstab
UUID=3e1cedae-3ca0-48f1-8170-e322de78f91e       /data           btrfs           defaults,autodefrag,compress=lzo                                        0 0
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cambiar-de-raid-a-single&#34;&gt;Cambiar de raid a single&lt;/h3&gt;

&lt;p&gt;Vamos a configurar el tipo de RAID que mas nos convenga, en mi caso como son torrents, no me importan tanto como si tuvieramos fotos o documentos creados por mi, asi que haremos un &lt;strong&gt;single&lt;/strong&gt; que no pierde espacio, pero no proporciona ninguna redundancia. Donde s鱈 la tendremos es en los metadatos del sistema de ficheros, los almacenaremos en RAID1 para que esten duplicados. Estas opciones las pone btrfs por defecto, y a mi me gusta, porque no se pierde excesivo espacio, y al menos para los metadatos, tendremos mas tolerancia a fallos.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ btrfs balance start -d convert=single /dev/sda
$ btrfs balance start -s convert=raid1 /dev/sda
$ btrfs balance start -m convert=raid1 /dev/sda
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Esta operacion la hemos hecho con &lt;code&gt;/data&lt;/code&gt; montado ya, casi todas las operaciones se pueden hacer con el sistema de ficheros montado.&lt;/p&gt;

&lt;h3 id=&#34;ver-el-espacio-en-disco-con-btrfs&#34;&gt;Ver el espacio en disco con btrfs&lt;/h3&gt;

&lt;p&gt;En este disco he metido mis datos ya (1.62 TiB) pero pongo los dos comandos respecto al uso en disco que utilizo&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ btrfs filesystem df /data
Data, single: total=1.62TiB, used=1.62TiB
System, RAID1: total=32.00MiB, used=208.00KiB
Metadata, RAID1: total=3.00GiB, used=1.95GiB
GlobalReserve, single: total=512.00MiB, used=0.00B
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ btrfs filesystem usage /data
$ sudo btrfs filesystem usage /data
Overall:
    Device size:                   3.87TiB
    Device allocated:              1.62TiB
    Device unallocated:            2.24TiB
    Device missing:                  0.00B
    Used:                          1.62TiB
    Free (estimated):              2.24TiB      (min: 1.12TiB)
    Data ratio:                       1.00
    Metadata ratio:                   2.00
    Global reserve:              512.00MiB      (used: 0.00B)

Data,single: Size:1.62TiB, Used:1.62TiB
   /dev/sda        1.62TiB

Metadata,RAID1: Size:3.00GiB, Used:1.95GiB
   /dev/sda        3.00GiB
   /dev/sdb        3.00GiB

System,RAID1: Size:32.00MiB, Used:208.00KiB
   /dev/sda       32.00MiB
   /dev/sdb       32.00MiB

Unallocated:
   /dev/sda        1.11TiB
   /dev/sdb      695.61GiB
   /dev/sdc      465.76GiB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Es importante usar este comando df, en lugar del mitico df de linux, porque aun este ultimo nos da informacion incorrecta.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>